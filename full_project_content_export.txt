--- Contenido del Proyecto Exportado el 2025-10-19 10:45:59 ---


// --- ./.env ---

# / .env
# Este archivo define las variables de entorno para el desarrollo local.
# NO subir este archivo a GitLab. Debe estar en el .gitignore.

# --- Configuración de la Base de Datos PostgreSQL ---
# Estos valores deben coincidir exactamente con los que espera el servicio 'db'
# en docker-compose.yml para la inicialización.
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=docuhub_db
POSTGRES_HOST=db  # El nombre del servicio en Docker Compose
POSTGRES_PORT=5432

# --- Configuración de la Aplicación FastAPI ---
# Esta es la URL completa que usará SQLAlchemy para conectarse.
# Está construida a partir de las variables anteriores.
DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}

# Clave secreta para firmar los tokens JWT.
# ¡Cambia esto por una cadena larga y aleatoria!
# Puedes generar una con: openssl rand -hex 32
SECRET_KEY=un_secreto_muy_dificil_de_adivinar_y_que_deberia_cambiar

# --- Configuración del Token (Opcional, pero recomendado) ---
ACCESS_TOKEN_EXPIRE_MINUTES=30
ALGORITHM=HS256

// --- ./Dockerfile ---

# /Dockerfile (Versión Verificada)

FROM python:3.11-slim-bookworm

# ... (instalación de pandoc, etc.) ...
RUN apt-get update && apt-get install -y --no-install-recommends \
    pandoc texlive-latex-base texlive-fonts-recommended texlive-xetex git \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# 1. Establecer el directorio de trabajo
WORKDIR /code

# 2. Copiar el archivo de requerimientos desde la carpeta 'app' del host
#    al directorio de trabajo '/code' en el contenedor.
COPY ./app/requirements.txt /code/

# 3. Ejecutar pip install. Se usará el archivo /code/requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# 4. Copiar todo el código de la aplicación
COPY ./app /code/app

# 5. Comando de ejecución
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]


// --- ./README.md ---

# Doc_hub
Application to write markdown files


// --- ./app/api/__init__.py ---



// --- ./app/api/dependencies.py ---

# /app/api/dependencies.py

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt
from pydantic import ValidationError
from sqlalchemy.orm import Session

from ..core import security
from ..core.config import settings
from ..db import models, schemas
from ..db.database import get_db
from ..services import user_service # Asumimos que este servicio existe

# Esta es la URL donde el frontend enviará el usuario y la contraseña para obtener un token.
reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/login/access-token"
)

def get_current_user(
    db: Session = Depends(get_db), token: str = Depends(reusable_oauth2)
) -> models.User:
    """
    Dependencia para obtener el usuario actual a partir de un token JWT.
    """
    try:
        payload = security.decode_token(token)
        if payload is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="No se pudo validar las credenciales",
            )
        token_data = schemas.TokenData(username=payload)
    except (jwt.JWTError, ValidationError):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="No se pudo validar las credenciales",
        )
    
    user = user_service.get_user_by_username(db, username=token_data.username)
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado.")
    return user


def get_current_active_user(
    current_user: models.User = Depends(get_current_user),
) -> models.User:
    """
    Dependencia para obtener el usuario actual que además esté activo.
    Se usa en la mayoría de los endpoints protegidos.
    """
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Usuario inactivo.")
    return current_user


def get_current_admin_user(
    current_user: models.User = Depends(get_current_active_user),
) -> models.User:
    """
    Dependencia para obtener el usuario actual, verificando que sea un administrador.
    Se usa en endpoints que requieren privilegios de administrador.
    """
    if not current_user.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="El usuario no tiene suficientes privilegios."
        )
    return current_user

// --- ./app/api/documents.py ---

# /app/api/documents.py

from fastapi import APIRouter, Depends, HTTPException, Body, status
from fastapi.responses import FileResponse
from typing import List, Dict, Any
import tempfile
import os
import subprocess
import yaml
from pathlib import Path

# Importaciones de nuestra aplicación
from ..api import dependencies
from ..db import models
from ..core.config import settings
from ..services import document_service # Usaremos el servicio para la lógica de Git

# Creamos un nuevo router. Todos los endpoints definidos aquí
# serán añadidos a la aplicación principal.
router = APIRouter()


@router.get("/tree", response_model=List[Dict[str, Any]])
def list_document_tree(
    current_user: models.User = Depends(dependencies.get_current_active_user),
):
    """
    Endpoint para listar la estructura jerárquica de todos los documentos.
    Devuelve una estructura de árbol para que el frontend la renderice.
    """
    try:
        return document_service.list_documents()
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error al listar los documentos: {e}"
        )


@router.get("/content/{file_path:path}", response_model=Dict[str, str])
def read_document_content(
    file_path: str,
    current_user: models.User = Depends(dependencies.get_current_active_user),
):
    """
    Endpoint para obtener el contenido de un archivo Markdown específico.
    """
    content = document_service.get_document_content(file_path)
    if content is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Documento no encontrado")
    
    return {"path": file_path, "content": content}


@router.post("/content/{file_path:path}")
def save_document_content(
    file_path: str,
    payload: dict = Body(...),
    current_user: models.User = Depends(dependencies.get_current_active_user),
):
    """
    Endpoint para guardar el contenido de un archivo y crear un commit en Git.
    Utiliza el document_service para encapsular la lógica.
    """
    content = payload.get("content", "")
    success = document_service.save_document_content(
        relative_path=file_path, content=content, author_name=current_user.username
    )
    if not success:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Error al guardar el documento.")
    
    return {"message": "Documento guardado y versionado con éxito."}


# /app/api/documents.py (Fragmento del endpoint /publish)

@router.post("/publish")
def publish_site(
    current_user: models.User = Depends(dependencies.get_current_admin_user),
):
    """
    Ejecuta 'mkdocs build' para generar el sitio estático.
    """
    try:
        # 1. Obtenemos la estructura de navegación desde el servicio
        nav_structure = document_service.generate_mkdocs_nav()
        
        # 2. Creamos el diccionario de configuración
        mkdocs_config = {
            'site_name': 'Documentación de Proyectos DATAZUCAR',
            'theme': {
                'name': 'material',
                'features': ['navigation.tabs', 'navigation.sections', 'navigation.expand']
            },
            'nav': nav_structure
        }
        
        # 3. Escribimos el archivo de configuración
        docs_path = Path(settings.DOCS_DIRECTORY)
        with open(docs_path / "mkdocs.yml", "w", encoding="utf-8") as f:
            yaml.dump(mkdocs_config, f, allow_unicode=True, default_flow_style=False)

        # 4. Ejecutamos el comando de build
        subprocess.run(
            ["mkdocs", "build", "-f", "mkdocs.yml", "-d", "/docs_build/site", "--clean"],
            cwd=docs_path.as_posix(),
            check=True
        )
        
        return {"message": "Sitio publicado con éxito."}
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Error al publicar el sitio: {str(e)}")


@router.get("/pdf/{file_path:path}")
def generate_pdf_from_document(
    file_path: str,
    current_user: models.User = Depends(dependencies.get_current_active_user),
):
    """
    Genera un PDF a partir de un archivo Markdown usando Pandoc.
    """
    source_path = Path(settings.DOCS_DIRECTORY) / file_path
    if not source_path.exists() or not source_path.is_file():
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Archivo Markdown no encontrado")

    with tempfile.NamedTemporaryFile(suffix=".pdf", delete=False) as tmp_pdf:
        output_pdf_path = tmp_pdf.name
    
    try:
        # Comando Pandoc para generar el PDF
        pandoc_command = [
            "pandoc", str(source_path),
            "--pdf-engine=xelatex",
            "-o", output_pdf_path,
            "-V", "documentclass=article",
            "-V", "mainfont=Calibri",
            "-V", "fontsize=11pt",
            "-V", "geometry:margin=2.5cm",
            "-V", r"header-includes=\usepackage{fancyhdr}\pagestyle{fancy}\fancyhf{}\rhead{" + source_path.parent.name.replace('_', ' ') + r"}\cfoot{\thepage}"
        ]

        subprocess.run(pandoc_command, check=True, capture_output=True, text=True)

        return FileResponse(
            path=output_pdf_path,
            media_type='application/pdf',
            filename=f"{source_path.stem}.pdf"
        )
    except subprocess.CalledProcessError as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Error al generar el PDF: {e.stderr}")
    finally:
        if os.path.exists(output_pdf_path):
            os.remove(output_pdf_path)

// --- ./app/api/login.py ---

# /app/api/login.py

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from datetime import timedelta

from ..core import security
from ..core.config import settings
from ..db import schemas
from ..db.database import get_db
from ..services import user_service # Asumimos que este servicio existe

router = APIRouter()

@router.post("/access-token", response_model=schemas.Token)
def login_for_access_token(
    db: Session = Depends(get_db), form_data: OAuth2PasswordRequestForm = Depends()
):
    """
    Endpoint para que un usuario inicie sesión con su username y password.
    Devuelve un token de acceso JWT.
    """
    user = user_service.authenticate_user(
        db, username=form_data.username, password=form_data.password
    )
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usuario o contraseña incorrectos",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        subject=user.username, expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

// --- ./app/api/project_docs.py ---


import os
import aiofiles # Para operaciones de archivo asíncronas
from fastapi import APIRouter, HTTPException, Depends, Body
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import List, Optional, Dict, Any

from app.api.dependencies import get_current_active_user # Asumiendo que quieres proteger estos endpoints
from app.db.models import User # Para el tipado de current_user

router = APIRouter()

# Directorio base donde están los documentos del proyecto dentro del contenedor
# Montado desde ./docs en el host a /docs_source en el contenedor app
DOCS_SOURCE_DIR = "/docs_source"

class FileNode(BaseModel):
    name: str
    path: str # Ruta relativa al DOCS_SOURCE_DIR
    type: str # 'file' o 'directory'
    children: Optional[List['FileNode']] = None

FileNode.model_rebuild() # Para la referencia recursiva de 'FileNode' en 'children'

class DocumentContent(BaseModel):
    content: str

def get_project_file_tree_recursive(root_dir: str, current_path: str = "") -> List[FileNode]:
    """
    Construye recursivamente el árbol de archivos y directorios,
    filtrando por archivos .md y listando directorios.
    """
    tree_nodes: List[FileNode] = []
    try:
        full_current_path = os.path.join(root_dir, current_path)
        if not os.path.exists(full_current_path) or not os.path.isdir(full_current_path):
            return []

        for item in sorted(os.listdir(full_current_path)):
            item_path_abs = os.path.join(full_current_path, item)
            item_path_rel = os.path.join(current_path, item) # Ruta relativa a DOCS_SOURCE_DIR

            if item.startswith('.'): # Ignorar archivos/directorios que comienzan con un punto
                continue

            if os.path.isdir(item_path_abs):
                children = get_project_file_tree_recursive(root_dir, item_path_rel)
                # Solo incluir directorios si tienen archivos .md o subdirectorios con .md (opcional, para no mostrar vacíos)
                # if children: # Descomentar si no quieres directorios vacíos (sin .md dentro)
                tree_nodes.append(FileNode(name=item, path=item_path_rel, type="directory", children=children))
            elif os.path.isfile(item_path_abs) and item.lower().endswith(".md"):
                tree_nodes.append(FileNode(name=item, path=item_path_rel, type="file"))
    except Exception as e:
        # Loggear el error sería bueno aquí
        print(f"Error traversing directory {full_current_path}: {e}")
        return [] # Retornar lista vacía en caso de error de permisos u otros
    return tree_nodes

def secure_join(base: str, user_path: str) -> str:
    """
    Une de forma segura la ruta base con la ruta proporcionada por el usuario,
    previniendo path traversal.
    """
    # Normalizar la ruta del usuario para resolver '..' etc.
    normalized_user_path = os.path.normpath(user_path)

    # Si la ruta normalizada comienza con '..' o es absoluta, es sospechosa
    if normalized_user_path.startswith("..") or os.path.isabs(normalized_user_path):
        raise HTTPException(status_code=400, detail="Ruta inválida o maliciosa.")

    # Construir la ruta completa
    full_path = os.path.normpath(os.path.join(base, normalized_user_path))

    # Verificar que la ruta resultante esté dentro del directorio base
    if not full_path.startswith(os.path.normpath(base) + os.sep) and full_path != os.path.normpath(base):
         # La segunda condición (full_path != os.path.normpath(base)) es para permitir el acceso al directorio base mismo si es necesario.
         # En este caso, user_path sería vacío o '.', lo cual es seguro.
        raise HTTPException(status_code=403, detail="Acceso prohibido a la ruta especificada.")

    return full_path


@router.get("/tree", response_model=List[FileNode], summary="Listar archivos y directorios de /docs_source")
async def list_project_docs(current_user: User = Depends(get_current_active_user)):
    if not os.path.exists(DOCS_SOURCE_DIR) or not os.path.isdir(DOCS_SOURCE_DIR):
        raise HTTPException(status_code=404, detail=f"Directorio fuente '{DOCS_SOURCE_DIR}' no encontrado en el servidor.")

    tree = get_project_file_tree_recursive(DOCS_SOURCE_DIR)
    return tree

@router.get("/content/{file_path:path}", response_model=DocumentContent, summary="Obtener contenido de un archivo de /docs_source")
async def get_project_doc_content(file_path: str, current_user: User = Depends(get_current_active_user)):
    try:
        abs_file_path = secure_join(DOCS_SOURCE_DIR, file_path)
        if not os.path.isfile(abs_file_path) or not abs_file_path.lower().endswith(".md"):
            raise HTTPException(status_code=404, detail="Archivo no encontrado o no es un archivo Markdown.")

        async with aiofiles.open(abs_file_path, mode="r", encoding="utf-8") as f:
            content = await f.read()
        return DocumentContent(content=content)
    except HTTPException: # Re-lanzar HTTPExceptions de secure_join o de aquí
        raise
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Archivo no encontrado.")
    except Exception as e:
        # Loggear el error
        print(f"Error leyendo archivo {file_path}: {e}")
        raise HTTPException(status_code=500, detail=f"Error al leer el archivo: {str(e)}")

@router.post("/content/{file_path:path}", summary="Guardar contenido de un archivo en /docs_source")
async def save_project_doc_content(
    file_path: str,
    payload: DocumentContent = Body(...),
    current_user: User = Depends(get_current_active_user)
):
    try:
        abs_file_path = secure_join(DOCS_SOURCE_DIR, file_path)

        # Asegurarse que el directorio padre existe, si no, crearlo (opcional, depende del caso de uso)
        # dir_name = os.path.dirname(abs_file_path)
        # if not os.path.exists(dir_name):
        #     os.makedirs(dir_name, exist_ok=True)

        if not abs_file_path.lower().endswith(".md"):
             raise HTTPException(status_code=400, detail="Solo se pueden guardar archivos Markdown (.md).")

        async with aiofiles.open(abs_file_path, mode="w", encoding="utf-8") as f:
            await f.write(payload.content)
        return JSONResponse(status_code=200, content={"message": "Archivo guardado exitosamente."})
    except HTTPException:
        raise
    except Exception as e:
        # Loggear el error
        print(f"Error guardando archivo {file_path}: {e}")
        raise HTTPException(status_code=500, detail=f"Error al guardar el archivo: {str(e)}")


// --- ./app/api/users.py ---

# /app/api/users.py

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

from ..api import dependencies
from ..db import models, schemas
from ..db.database import get_db
from ..services import user_service # Asumimos que este servicio existe

router = APIRouter()

@router.post("/", response_model=schemas.User, status_code=status.HTTP_201_CREATED)
def create_user(
    user_in: schemas.UserCreate,
    db: Session = Depends(get_db),
    current_admin_user: models.User = Depends(dependencies.get_current_admin_user)
):
    """
    Crea un nuevo usuario en el sistema.
    Solo accesible para administradores.
    """
    user = user_service.get_user_by_email(db, email=user_in.email)
    if user:
        raise HTTPException(
            status_code=400,
            detail="Ya existe un usuario con este correo electrónico.",
        )
    return user_service.create_user(db, user_in=user_in)


@router.get("/", response_model=List[schemas.User])
def read_users(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_admin_user: models.User = Depends(dependencies.get_current_admin_user)
):
    """
    Obtiene una lista de usuarios.
    Solo accesible para administradores.
    """
    users = user_service.get_users(db, skip=skip, limit=limit)
    return users


@router.get("/{user_id}", response_model=schemas.User)
def read_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_admin_user: models.User = Depends(dependencies.get_current_admin_user)
):
    """
    Obtiene un usuario específico por su ID.
    Solo accesible para administradores.
    """
    db_user = user_service.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    return db_user

// --- ./app/core/__init__.py ---



// --- ./app/core/config.py ---

#
# /app/core/config.py
import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    PROJECT_NAME: str = "DocuHub Interno"
    PROJECT_VERSION: str = "1.0.0"
    API_V1_STR: str = "/api/v1"

    # Lee desde las variables de entorno inyectadas por Docker Compose
    DATABASE_URL: str = os.getenv("DATABASE_URL")
    SECRET_KEY: str = os.getenv("SECRET_KEY")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    ALGORITHM: str = "HS256"

    # Rutas del sistema de archivos
    DOCS_DIRECTORY: str = "/docs_source"

    class Config:
        case_sensitive = True

# Instancia única que será importada por otros módulos
settings = Settings()

// --- ./app/core/security.py ---

# /app/core/security.py

from datetime import datetime, timedelta
from typing import Optional, Any

from jose import JWTError, jwt
from passlib.context import CryptContext

from app.core.config import settings

# 1. Contexto de Passlib para el Hashing de Contraseñas
#    Usamos bcrypt, que es el estándar recomendado para contraseñas.
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


# 2. Funciones de Contraseña

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verifica si una contraseña en texto plano coincide con su versión hasheada.

    Args:
        plain_password (str): La contraseña sin hashear.
        hashed_password (str): La contraseña hasheada desde la base de datos.

    Returns:
        bool: True si las contraseñas coinciden, False en caso contrario.
    """
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """
    Genera el hash de una contraseña en texto plano.

    Args:
        password (str): La contraseña a hashear.

    Returns:
        str: La contraseña hasheada.
    """
    return pwd_context.hash(password)


# 3. Funciones de Token JWT (JSON Web Token)

def create_access_token(
    subject: Any, expires_delta: Optional[timedelta] = None
) -> str:
    """
    Crea un nuevo token de acceso JWT.

    Args:
        subject (Any): El sujeto del token (generalmente el ID o username del usuario).
        expires_delta (Optional[timedelta]): Tiempo de vida del token. Si no se provee,
                                             se usa el valor de la configuración.

    Returns:
        str: El token JWT codificado.
    """
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
    
    # El 'payload' del token contiene los datos que queremos guardar en él.
    # 'exp' (expiration) y 'sub' (subject) son claims estándar de JWT.
    to_encode = {"exp": expire, "sub": str(subject)}
    
    encoded_jwt = jwt.encode(
        claims=to_encode, 
        key=settings.SECRET_KEY, 
        algorithm=settings.ALGORITHM
    )
    return encoded_jwt


def decode_token(token: str) -> Optional[str]:
    """
    Decodifica un token JWT para obtener el 'subject' (ID/username del usuario).

    Args:
        token (str): El token JWT a decodificar.

    Returns:
        Optional[str]: El 'subject' del token si es válido, None en caso contrario.
    """
    try:
        payload = jwt.decode(
            token=token, 
            key=settings.SECRET_KEY, 
            algorithms=[settings.ALGORITHM]
        )
        # Extraemos el 'subject' del payload
        return payload.get("sub")
    except JWTError:
        # Si el token ha expirado, tiene una firma inválida, etc., jose lanzará un error.
        # En ese caso, devolvemos None.
        return None

// --- ./app/db/__init__.py ---

#


// --- ./app/db/database.py ---

# /app/db/database.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# Cambia la importación a una ruta relativa explícita desde la raíz del paquete 'app'
from ..core.config import settings # <-- CAMBIO CLAVE AQUÍ

# El resto del archivo se mantiene igual
engine = create_engine(settings.DATABASE_URL)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

// --- ./app/db/models.py ---

# /app/db/models.py

from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Boolean, Text
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func # Para obtener la fecha y hora actual de la BD

# Importamos la clase Base desde nuestro archivo de configuración de la BD.
# Todas nuestras tablas heredarán de esta clase.
from .database import Base

class User(Base):
    """
    Modelo de la tabla de Usuarios.
    Almacena la información de inicio de sesión y los roles.
    """
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    is_admin = Column(Boolean, default=False)

    # Relación uno-a-muchos: Un usuario puede tener muchos comentarios.
    comments = relationship("Comment", back_populates="owner")


class Comment(Base):
    """
    Modelo de la tabla de Comentarios.
    Almacena los comentarios asociados a cada documento.
    """
    __tablename__ = "comments"

    id = Column(Integer, primary_key=True, index=True)
    document_path = Column(String(512), index=True, nullable=False)
    content = Column(Text, nullable=False)
    
    # func.now() inserta la fecha y hora del servidor de la BD automáticamente.
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Clave foránea que enlaza con la tabla de usuarios.
    owner_id = Column(Integer, ForeignKey("users.id"))

    # Relación muchos-a-uno: Un comentario pertenece a un solo usuario.
    owner = relationship("User", back_populates="comments")


class DocumentLock(Base):
    """
    Modelo de la tabla de Bloqueo de Documentos.
    Evita la edición simultánea.
    """
    __tablename__ = "document_locks"

    # La ruta del documento es la clave primaria. Solo puede haber un bloqueo por documento.
    document_path = Column(String(512), primary_key=True)
    
    locked_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Clave foránea que indica qué usuario tiene el bloqueo.
    locked_by_user_id = Column(Integer, ForeignKey("users.id"))


// --- ./app/db/schemas.py ---

# /app/db/schemas.py

from pydantic import BaseModel, EmailStr, Field
from typing import Optional, List
from datetime import datetime

# ==============================================================================
# Esquemas para la gestión de USUARIOS (Users)
# ==============================================================================

# --- Atributos base compartidos por todos los esquemas de usuario ---
class UserBase(BaseModel):
    username: str = Field(..., min_length=3, max_length=50, description="Nombre de usuario único")
    email: EmailStr = Field(..., description="Correo electrónico del usuario")
    is_active: bool = True

# --- Esquema para la CREACIÓN de un usuario (recibido por la API) ---
# Hereda de UserBase y añade el campo de la contraseña.
class UserCreate(UserBase):
    password: str = Field(..., min_length=8, description="Contraseña del usuario")

# --- Esquema para la ACTUALIZACIÓN de un usuario (recibido por la API) ---
# Todos los campos son opcionales.
class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    is_active: Optional[bool] = None
    password: Optional[str] = Field(None, min_length=8)

# --- Esquema para representar un usuario que se DEVUELVE desde la API ---
# Hereda de UserBase y añade el 'id'. NUNCA debe devolver la contraseña.
class User(UserBase):
    id: int

    class Config:
        # Permite a Pydantic mapear automáticamente los datos desde un
        # objeto de SQLAlchemy a este schema.
        from_attributes = True


# ==============================================================================
# Esquemas para la gestión de COMENTARIOS (Comments)
# ==============================================================================

# --- Atributos base para un comentario ---
class CommentBase(BaseModel):
    content: str = Field(..., min_length=1, description="Contenido del comentario")

# --- Esquema para la CREACIÓN de un comentario ---
class CommentCreate(CommentBase):
    document_path: str = Field(..., description="Ruta del documento al que pertenece el comentario")

# --- Esquema para representar un comentario que se DEVUELVE desde la API ---
# Incluye información del comentario y del usuario que lo creó.
class Comment(CommentBase):
    id: int
    document_path: str
    created_at: datetime
    owner_id: int
    owner: User  # Anida el schema 'User' para devolver los datos del propietario

    class Config:
        orm_mode = True


# ==============================================================================
# Esquemas para la gestión de DOCUMENTOS y su bloqueo
# ==============================================================================

# --- Esquema para los datos de un documento (enviados y recibidos) ---
class Document(BaseModel):
    path: str
    content: str

# --- Esquema para representar el estado de un bloqueo ---
class DocumentLock(BaseModel):
    document_path: str
    locked_at: datetime
    locked_by: User # Anida el schema 'User' para mostrar quién tiene el bloqueo

    class Config:
        orm_mode = True


# ==============================================================================
# Esquemas para la AUTENTICACIÓN (Login)
# ==============================================================================

# --- Esquema para la respuesta del token de acceso ---
class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"

# --- Esquema para los datos contenidos dentro del token JWT ---
class TokenData(BaseModel):
    username: Optional[str] = None


// --- ./app/initial_data.py ---

# /app/initial_data.py

import asyncio
from sqlalchemy.orm import Session
from app.db.database import SessionLocal, engine, Base
from app.db import models, schemas
from app.services import user_service

# --- IMPORTANTE ---
# Asegúrate de que las tablas estén creadas antes de intentar insertar datos.
# Esta línea es redundante si main.py ya la ejecutó, pero es segura de correr de nuevo.
Base.metadata.create_all(bind=engine)

# Obtener una sesión de base de datos
db: Session = SessionLocal()

async def create_initial_user():
    print("Verificando si el usuario administrador ya existe...")
    
    # Comprobar si ya existe un usuario con ese nombre o email
    user = user_service.get_user_by_username(db, username="admin")
    
    if user:
        print("El usuario 'admin' ya existe. No se tomará ninguna acción.")
    else:
        print("Creando usuario 'admin'...")
        
        # Datos del nuevo superusuario
        user_in = schemas.UserCreate(
            username="admin",
            email="admin@gmail.com",  # Puedes cambiar este email
            password="David*2017",
            is_active=True
        )
        
        # Usamos el servicio para crear el usuario (que se encarga del hashing)
        new_user = user_service.create_user(db, user_in=user_in)
        
        # Hacemos que sea administrador
        new_user.is_admin = True
        db.add(new_user)
        db.commit()
        
        print("¡Superusuario 'admin' creado con éxito!")
        print("Contraseña: admin")

    # Cerrar la sesión de la base de datos
    db.close()

if __name__ == "__main__":
    # Ejecutar la función asíncrona
    # En versiones modernas de Python, puedes simplemente llamar a await en el nivel superior,
    # pero para compatibilidad, usamos asyncio.run()
    asyncio.run(create_initial_user())

// --- ./app/main.py ---

# /app/main.py (Versión Refactorizada)

from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse

from app.db.database import engine, Base
from app.db import models
from app.core.config import settings

# --- API Routers ---
# Importamos los routers que creamos en la carpeta /api
from app.api import login, users, documents
from app.api import project_docs

# --------------------------------------------------------------------------
# 1. Creación de las Tablas de la Base de Datos
# --------------------------------------------------------------------------
# Es crucial que los modelos se importen antes de llamar a create_all
# para que SQLAlchemy los conozca.
Base.metadata.create_all(bind=engine)

# --------------------------------------------------------------------------
# 2. Creación de la Instancia Principal de la Aplicación FastAPI
# --------------------------------------------------------------------------
app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.PROJECT_VERSION,
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

# --------------------------------------------------------------------------
# 3. Inclusión de los Routers de la API
# --------------------------------------------------------------------------
# Aquí "conectamos" los endpoints definidos en otros archivos.
# Todas las rutas en 'login.router' comenzarán con '/api/v1/login'.
app.include_router(login.router, prefix=f"{settings.API_V1_STR}/login", tags=["Login"])
app.include_router(users.router, prefix=f"{settings.API_V1_STR}/users", tags=["Users"])
app.include_router(documents.router, prefix=f"{settings.API_V1_STR}/documents", tags=["Documents"])
app.include_router(project_docs.router, prefix=f"{settings.API_V1_STR}/project-docs", tags=["Project Docs Editor"])



# --------------------------------------------------------------------------
# 4. Servir el Frontend (Opcional, pero necesario para el editor)
# --------------------------------------------------------------------------
# Montamos el directorio 'static' para servir CSS/JS
app.mount("/static", StaticFiles(directory="app/static"), name="static")

# Un endpoint para servir la página de login
@app.get("/login", response_class=HTMLResponse, tags=["Frontend"])
async def read_login_page():
    with open("app/static/login.html") as f:
        return HTMLResponse(content=f.read())

# Un endpoint para servir la página principal del editor
@app.get("/", response_class=HTMLResponse, tags=["Frontend"])
@app.get("/editor", response_class=HTMLResponse, tags=["Frontend"])
async def read_editor_page():
    with open("app/static/editor.html") as f:
        return HTMLResponse(content=f.read())


// --- ./app/requirements.txt ---

# /app/requirements.txt

fastapi
uvicorn
python-multipart

# Base de Datos y ORM
sqlalchemy
psycopg2-binary

# Configuración y Validación
# pydantic[email] instalará pydantic junto con la dependencia 'email-validator'
pydantic[email]
pydantic-settings

# Seguridad y Autenticación
python-jose[cryptography]
passlib
bcrypt

# Documentación
mkdocs
mkdocs-material
PyYAML

# Utilidades (Git)
GitPython
aiofiles


// --- ./app/services/__init__.py ---



// --- ./app/services/document_service.py ---

# /app/services/document_service.py

import os
import git
from pathlib import Path
from typing import List, Optional, Dict, Any

from app.core.config import settings

class DocumentService:
    """
    Servicio para manejar la lógica de negocio relacionada con los documentos,
    incluyendo la interacción con el sistema de archivos y Git.
    """
    def __init__(self, docs_path: str = settings.DOCS_DIRECTORY):
        self.docs_path = Path(docs_path)
        if not self.docs_path.exists():
            self.docs_path.mkdir(parents=True)
        
        try:
            self.repo = git.Repo(self.docs_path)
        except git.InvalidGitRepositoryError:
            self.repo = git.Repo.init(self.docs_path)

    def _get_full_path(self, relative_path: str) -> Path:
        """Construye y valida la ruta completa y segura de un archivo."""
        full_path = (self.docs_path / relative_path).resolve()
        if not full_path.is_relative_to(self.docs_path.resolve()):
            raise ValueError("Acceso a ruta no permitido (Path Traversal).")
        return full_path

    def list_documents(self) -> List[Dict[str, Any]]:
        """Lista todos los documentos y directorios de forma jerárquica."""
        def build_tree(current_path: Path):
            tree = []
            for item in sorted(current_path.iterdir()):
                if item.name.startswith('.') or item.name == 'mkdocs.yml':
                    continue
                
                relative_path = item.relative_to(self.docs_path).as_posix()
                if item.is_dir():
                    tree.append({
                        "name": item.name,
                        "type": "directory",
                        "path": relative_path,
                        "children": build_tree(item)
                    })
                elif item.is_file() and item.suffix == '.md':
                    tree.append({
                        "name": item.name,
                        "type": "file",
                        "path": relative_path
                    })
            return tree
        return build_tree(self.docs_path)

    def get_document_content(self, relative_path: str) -> Optional[str]:
        """Lee el contenido de un archivo Markdown."""
        try:
            full_path = self._get_full_path(relative_path)
            return full_path.read_text(encoding='utf-8')
        except (FileNotFoundError, ValueError):
            return None
        
    def save_document_content(self, relative_path: str, content: str, author_name: str) -> bool:
        """Guarda el contenido de un documento y realiza un commit en Git."""
        try:
            full_path = self._get_full_path(relative_path)
            full_path.parent.mkdir(parents=True, exist_ok=True)
            full_path.write_text(content, encoding='utf-8')

            self.repo.git.add(str(full_path))
            if self.repo.is_dirty(path=str(full_path)):
                self.repo.git.commit('-m', f"Doc '{relative_path}' actualizado por {author_name}")
            return True
        except Exception as e:
            print(f"Error al guardar documento {relative_path}: {e}")
            # Considerar un rollback de Git si el commit falla
            try:
                self.repo.git.reset('--hard', 'HEAD')
            except git.GitCommandError:
                pass # Puede fallar si no había nada que resetear
            return False
    
    def generate_mkdocs_nav(self) -> List[Dict[str, Any]]:
        """
        Genera la estructura de navegación jerárquica para el archivo mkdocs.yml.
        """
        def build_nav(current_path: Path):
            nav_items = []
            for item in sorted(current_path.iterdir()):
                if item.name.startswith('.') or item.name == 'mkdocs.yml':
                    continue
                
                relative_path = item.relative_to(self.docs_path).as_posix()
                
                if item.is_dir():
                    dir_name = item.name.replace('_', ' ').title()
                    children_nav = build_nav(item)
                    if children_nav:
                        nav_items.append({dir_name: children_nav})
                elif item.is_file() and item.suffix == '.md':
                    file_name = item.stem.replace('_', ' ').title()
                    nav_items.append({file_name: relative_path})
            return nav_items
        return build_nav(self.docs_path)

# Creamos una instancia única del servicio para que sea fácil de importar y usar
document_service = DocumentService()

// --- ./app/services/user_service.py ---

# /app/services/user_service.py

from sqlalchemy.orm import Session
from typing import List, Optional

from app.core import security
from app.db import models, schemas

def get_user(db: Session, user_id: int) -> Optional[models.User]:
    """Obtiene un usuario por su ID."""
    return db.query(models.User).filter(models.User.id == user_id).first()

def get_user_by_email(db: Session, email: str) -> Optional[models.User]:
    """Obtiene un usuario por su correo electrónico."""
    return db.query(models.User).filter(models.User.email == email).first()

def get_user_by_username(db: Session, username: str) -> Optional[models.User]:
    """Obtiene un usuario por su nombre de usuario."""
    return db.query(models.User).filter(models.User.username == username).first()

def get_users(db: Session, skip: int = 0, limit: int = 100) -> List[models.User]:
    """Obtiene una lista de usuarios con paginación."""
    return db.query(models.User).offset(skip).limit(limit).all()

def create_user(db: Session, user_in: schemas.UserCreate) -> models.User:
    """
    Crea un nuevo usuario en la base de datos.
    Hashea la contraseña antes de guardarla.
    """
    hashed_password = security.get_password_hash(user_in.password)
    db_user = models.User(
        username=user_in.username,
        email=user_in.email,
        hashed_password=hashed_password,
        is_active=user_in.is_active
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def authenticate_user(db: Session, username: str, password: str) -> Optional[models.User]:
    """
    Autentica a un usuario. Retorna el usuario si la autenticación es exitosa,
    de lo contrario retorna None.
    """
    user = get_user_by_username(db, username=username)
    if not user:
        return None
    if not security.verify_password(password, user.hashed_password):
        return None
    return user

// --- ./app/static/editor.html ---

<!doctype html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>DocuHub - Editor Profesional</title>

        <!-- CSS de Librerías Externas -->
        <link
            rel="stylesheet"
            href="https://unpkg.com/easymde/dist/easymde.min.css"
        />

        <!-- ESTILOS GLOBALES DE LA APLICACIÓN -->
        <link rel="stylesheet" href="/static/styles.css" />

        <!-- JS de Librerías Externas (Cargadas antes de tu lógica o de EasyMDE si las necesita) -->
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
        <script src="https://unpkg.com/easymde/dist/easymde.min.js"></script>
    </head>
    <body>
        <div class="app-layout">
            <!-- Panel Izquierdo: Árbol de Documentos -->
            <aside class="sidebar">
                <div class="sidebar-header">
                    <h2>Documentación</h2>
                    <button id="theme-switcher" title="Cambiar tema">☀️</button>
                </div>
                <div id="file-tree" class="file-tree">
                    <p>Cargando estructura...</p>
                </div>
            </aside>

            <!-- Panel Derecho: Editor y Vista Previa -->
            <main class="main-content">
                <div class="editor-container" id="editor-area-wrapper">
                    <div class="editor-pane">
                        <textarea id="markdown-editor"></textarea>
                    </div>
                    <div class="preview-pane" id="preview">
                        <!-- El contenido se generará dinámicamente -->
                    </div>
                </div>
                <div class="editor-actions">
                    <span id="status-message"></span>
                    <button id="save-btn" disabled>Guardar</button>
                    <button id="publish-btn">Publicar Sitio</button>
                </div>
            </main>
        </div>

        <!-- LÓGICA DEL EDITOR -->
        <script
            defer
            src="/static/editor_logic.js?v=TIMESTAMP_O_RANDOM"
        ></script>
    </body>
</html>


// --- ./app/static/login.html ---

<!doctype html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>DocuHub - Iniciar Sesión</title>

        <!-- ESTILOS GLOBALES DE LA APLICACIÓN -->
        <link rel="stylesheet" href="/static/styles.css" />
    </head>
    <body>
        <div class="login-container">
            <form class="login-form" id="login-form">
                <h1>DocuHub</h1>
                <div class="input-group">
                    <label for="username">Usuario</label>
                    <input
                        type="text"
                        id="username"
                        name="username"
                        required
                        autocomplete="username"
                    />
                </div>
                <div class="input-group">
                    <label for="password">Contraseña</label>
                    <input
                        type="password"
                        id="password"
                        name="password"
                        required
                        autocomplete="current-password"
                    />
                </div>
                <button type="submit">Iniciar Sesión</button>
                <p id="error-message" class="error-message"></p>
            </form>
        </div>

        <script>
            document.addEventListener("DOMContentLoaded", () => {
                // --- Aplicar tema guardado al cargar la página ---
                const savedTheme =
                    localStorage.getItem("docuhub_theme") || "light";
                document.documentElement.setAttribute("data-theme", savedTheme);

                // --- Lógica del formulario de login ---
                const loginForm = document.getElementById("login-form");
                const errorElement = document.getElementById("error-message");

                loginForm.addEventListener("submit", async (e) => {
                    e.preventDefault();
                    const username = e.target.username.value;
                    const password = e.target.password.value;
                    errorElement.textContent = "";

                    const formData = new URLSearchParams();
                    formData.append("username", username);
                    formData.append("password", password);

                    try {
                        // La ruta de la API de login es absoluta desde la raíz del dominio
                        const response = await fetch(
                            "/api/v1/login/access-token",
                            {
                                method: "POST",
                                headers: {
                                    "Content-Type":
                                        "application/x-www-form-urlencoded",
                                },
                                body: formData,
                            },
                        );

                        if (response.ok) {
                            const data = await response.json();
                            localStorage.setItem(
                                "docuhub_token",
                                data.access_token,
                            );
                            // Redirigir a la RUTA /editor, que sirve el editor.html
                            window.location.href = "/editor";
                        } else {
                            const errorData = await response
                                .json()
                                .catch(() => ({
                                    detail: "Error al procesar la respuesta del servidor.",
                                }));
                            errorElement.textContent =
                                errorData.detail ||
                                "Usuario o contraseña incorrectos.";
                        }
                    } catch (error) {
                        console.error("Error de login:", error);
                        errorElement.textContent =
                            "Error de conexión. Por favor, inténtelo más tarde.";
                    }
                });
            });
        </script>
    </body>
</html>


// --- ./docker-compose.yml ---

# /docker-compose.yml (VERSIÓN FINAL Y ROBUSTA)
services:
  app:
    build: .
    # CAMBIO CLAVE: Ahora depende de que el servicio 'db' esté 'saludable'
    depends_on:
      db:
        condition: service_healthy
    expose:
      - "8000"
    volumes:
      - ./app:/code/app
      - ./docs:/docs_source
      - docs_build:/docs_build
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - SECRET_KEY=${SECRET_KEY}
    restart: unless-stopped

  db:
    image: postgres:14-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    # --- NUEVA SECCIÓN: HEALTHCHECK ---
    healthcheck:
      # Comando que Docker ejecutará para comprobar la salud del servicio.
      # pg_isready es una utilidad de PostgreSQL que devuelve 0 si el servidor está listo.
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s # Comprobar cada 5 segundos
      timeout: 5s # Esperar 5 segundos por una respuesta
      retries: 5 # Intentarlo 5 veces antes de marcarlo como 'unhealthy'
    restart: unless-stopped

  nginx:
    image: nginx:1.21-alpine
    ports:
      - "8080:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf
      - docs_build:/var/www/html
    depends_on:
      - app
    restart: unless-stopped

volumes:
  docs_build:
  postgres_data:


// --- ./docs/Bi-Versat/manual de usuario.md ---

*** BI Versat***


// --- ./docs/Versat/Configuración/manual de usuario.md ---

*** Configuracion ***


// --- ./nginx/nginx.conf ---

# /nginx/nginx.conf

# Define el servidor upstream (nuestra aplicación FastAPI)
upstream docuhub_app {
    server app:8000; # 'app' es el nombre del servicio FastAPI en docker-compose
}

server {
    listen 80;
    # server_name localhost; # O tu nombre de host si usas uno

    # Ruta para el sitio de documentación estática (MkDocs)
    # Ejemplo de acceso: http://localhost:8080/docs/
    location /docs/ {
        alias /var/www/html/site/; # Mapeado desde el volumen docs_build
        index index.html;
        try_files $uri $uri/ =404;
    }

    # Ruta principal para la aplicación FastAPI (editor, login, API, estáticos de la app)
    # Todas las demás solicitudes (ej. /, /editor, /login, /api/v1/..., /static/...)
    # serán pasadas al backend FastAPI.
    location / {
        proxy_pass http://docuhub_app; # Apunta al upstream definido arriba

        # Headers importantes para el proxy inverso
        proxy_set_header Host $host; # Pasa el Host header original
        proxy_set_header X-Real-IP $remote_addr; # Pasa la IP real del cliente
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Lista de IPs si hay múltiples proxies
        proxy_set_header X-Forwarded-Proto $scheme; # Pasa el protocolo original (http o https)

        # Opcional: Ajustes de timeouts si FastAPI es lento en responder (generalmente no necesario para 404)
        # proxy_connect_timeout 60s;
        # proxy_read_timeout    60s;
    }
}
